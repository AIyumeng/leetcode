# 10. regular-expression-matching

## 🔗 题目链接

[LeetCode 10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

## 💡 思路

* 使用动态规划
* 状态定义: dp[i][j] 表示 s[0..i-1] 和 p[0..j-1] 是否匹配
* 状态转移:
  + 如果 p[j-1] 是普通字符或 '.', 则 dp[i][j] = dp[i-1][j-1] 且 s[i-1] == p[j-1] 或 p[j-1] == '.'
  + 如果 p[j-1] 是 '*', 则分两种情况:
    - '*' 代表零个前面的元素: dp[i][j] = dp[i][j-2]
    - '*' 代表一个或多个前面的元素: dp[i][j] = dp[i-1][j] 且 (s[i-1] == p[j-2] 或 p[j-2] == '.')
* 初始化: dp[0][0] = True, 其他 dp[0][j] 根据 p 的形式初始化
* 最终结果: dp[len(s)][len(p)]

## 🧩 代码

[code](../problems/10.regular-expression-matching.py)

## 📝 分析

* 初始化 dp 数组
  + dp[0][0] = True, 表示空字符串和空模式匹配
  + dp[0][j] = dp[0][j-2] if p[j-1] == '*'  (表示 '*' 可以匹配零个前面的元素)
  + dp[i][0] = False for i > 0 (非空字符串不能匹配空模式)
* 最小编辑距离也是动态规划的经典应用
* [菜鸟教程 - 正则表达式](https://www.runoob.com/python/python-reg-expressions.html)
